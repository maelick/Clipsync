\chapter{Implémentation de la solution proposée}
\renewcommand{\leftmark}{\thechapter.~~Implémentation de la solution proposée}
\label{chap:implem}
Ce chapitre justifie premièrement les choix qui fait avant et
pendant l'implémentationde de l'architecture baptisée \emph{Clipsync}.
Ensuite une présentation de l'utilisation des
logiciels produits est faite. Après des vérifications de performances sont
effectuées sur ces logiciels et enfin les faiblesses du logiciel sont mises
en avant afin de déterminer les éléments prioritaires à développer lors de
l'évolution future du logiciel.

\section{Choix des outils}
Le langage de programmation C++ a été choisi afin d'implémenter Clipsync,
celui-ci permettant d'avoir un code compilé nativement et ainsi optimisé
pour la machine hôte. Bien que ceci soit une source d'erreurs, il permet
aussi de gérer la mémoire manuellement, ce qui implique un gain de
performances. En revanche les client locaux, à savoir GTKCLip et Shellclip,
ont eux été implémentés en Python. Ce langage de haut niveau en comparaison
au C++ offre la possibilité d'écrire ces deux clients sous forme de scripts
de taille réduite. La perte de performance par rapport au C++ est peu
importante vu que ces scripts utilisent un protocole de communication simple
et servent uniquement d'interface entre l'utilisateur et le client P2P.

La librairie POCO\cite{poco} a été utilisée principalement comme bibliothèque
pour la manipulation de sockets portables. Ceci permet d'avoir une
compatibilité théorique avec Microsoft Windows, bien que celle-ci n'a pas
été testée. De plus POCO offrant un grand nombre de service, la librairie
a aussi été utilisée pour la gestion des threads et des timers, la
configuration du logiciel grâce à un fichier XML, pour la protection de
zones critiques avec mutex, pour la génération de
nombres pseudo-aléatoires et pour la cryptographie. L'algorithme de chiffrement
utilisé est l'\emph{AES}\cite{daemen2002the} (Advanced Encryption Standard,
aussi connu sous le nom de \emph{Rijndael}). Étant l'algorithme choisi par le
gouvernement américain, cet algorithme utilisant une clé de 256 bits permet un
niveau de sécurité très largement acceptable.

Afin d'éviter les erreurs en C++, et en particulier pour détecter les fuites
de mémoire, Valgrind\cite{valgrind} a été utilisé. Celui-ci est à la fois un
debugger, un \emph{memory-checker} et un \emph{profiler}. Celui-ci permet
de debugger le programme pendant le développement et est utilisé dans la
suite de ce chapitre afin d'analyser les performances du logiciel et pour
s'assurer que le programme n'est pas victime de fuites de mémoires.
Bazaar\cite{bzr} a été utilisé comme gestionnaire de versions décentralisé et
Launchpad\cite{launchpad} a été choisi comme forge sur laquelle déposer le
logiciel produit. Ce dernier est donc disponible sous license GPL à l'adresse
\url{https://launchpad.net/clipsync}.

\section{Utilisation des logiciels}
Avant de pouvoir récupérer, compiler et utiliser le logiciel, il est nécessaire
d'avoir les librairies et outils suivants:
\begin{itemize}
\item Bazaar: \url{http://bazaar.canonical.com/}
\item GCC: \url{http://gcc.gnu.org/}
\item GNU Make: \url{http://www.gnu.org/software/make/}
\item POCO version 1.3.6 minimum: \url{http://pocoproject.org/}
\item Python 2.6 ou 2.7: \url{http://www.python.org/}
\item PyGTK et GTK version 2: \url{http://www.pygtk.org/}
\item Doxygen peut être optionnellement installé pour générer la documentation
  du projet: \url{http://www.stack.nl/~dimitri/doxygen/}
\end{itemize}

Tous ces logiciels peuvent êtres installés sous une distribution GNU/Linux
basée sur une Debian récente grâce à la commande:
\begin{verbatim}
sudo apt-get install bzr gcc make libpoco-dev
  python-gtk2 doxygen
\end{verbatim}
Le code source peut alors être récupéré grâce à la commande:
\begin{verbatim}
bzr branch lp:clipsync
\end{verbatim}
Clipsync peut alors être compilé grâce à GNU Make dans le dossier
\emph{src/clipsync}.
L'exécutable produit peut alors être lancé en passant en paramètre un nom
de fichier XML servant à configurer le logiciel. Voici la liste des balises
et leur description:
\begin{itemize}
\item \emph{net\_frontend}:
  \begin{itemize}
  \item \emph{interface}: interface réseau utilisée pour les communications
    réseau
  \item \emph{use\_ipv6}: booléen servant à indiquer l'utilisation d'IPv6.
    Cette fonctionnalité n'est cependant pas disponible pour le moment et
    l'option a seulement été ajoutée pour l'évolution future du loigiciel.
  \item \emph{port}: port TCP utilisé pour écouter les connexions TCP
    entrantes. C'est sur ce port que le pair sera contacté par les autres
    pairs du réseau.
  \item \emph{bcast\_port}: port UDP utilisé pour l'envoi et la réception de
    messages broadcast.
  \item \emph{bcast\_interval}: interval en millisecondes utilisé pour l'envoi
    de messages broadcast.
  \item \emph{peer\_name}: nom servant à identifier ce pair sur le réseau et
    devant être unique pour ce pair.
  \item \emph{group}: nom du groupe de pairs. Chaque pair du réseau devra
    posséder le même nom de groupe dans sa configuration.
  \item \emph{passphrase} et \emph{salt}: mot de passe et sel\footnote{Le
      salage en cryptographie permet de renforcer la sécurité d'un algorithme
      de chiffrement\cite{schneier-crypto}} servant à générer la clé pour le
    chiffrement par AES. Ces deux valeurs doivent être identiques sur chaque
    pair. Il est possible de supprimer ces deux valeurs, de lancer le
    logiciel qui va générer des valeurs aléatoires qui peuvent ensuite
    être copiées sur les autres pairs.
  \item \emph{keepalive\_delay}: délai en millisecondes après lequel la
    connexion est fermée si aucun message OK n'est reçu.
  \item \emph{keepalive\_interval}: interval en millisecondes utilisé pour
    l'envoi de messages OK.
  \item \emph{verbose}, \emph{verbose\_bcast}, \emph{verbose\_peer}:
    booléens permettant d'activer ou de désactiver le mode verbeux
    \footnote{Le mode verbeux permet d'afficher sur la sortie standard
    des informations sur l'activité du logiciel.} de Clipsync.
  \end{itemize}
\item \emph{local\_frontend}:
  \begin{itemize}
  \item \emph{local\_port}: port TCP en local utilisé pour communiquer avec les
    clients locaux.
  \item \emph{verbose}: booléen activant le mode verbeux pour l'interface avec
    les clients locaux.
  \end{itemize}
\end{itemize}

Le script \emph{gen\_config.py} permet de générer un fichier de configuration
en passant en argument dans l'ordre: le nom du pair, le nom du groupe de pairs,
l'interface réseau à utiliser et optionnellement: le port, le port broadcast,
le port local, la longueur du mot de passe à générer et la longueur du
sel à générer.

L'utilisation de Shellclip et GTKClip est possible en exécutant les scripts
Python et en passant en paramètre le port TCP local permettant de contacter
Clipsync.

\section{Vérifications de performances}
Valgrind, utilisé pendant le développement de Clipsync comme debugger,
offre aussi la possibilité d'être utilisé comme profiler. Afin d'analyser
les performances, il a d'abord été utilisé en tant que vérificateur
de mémoire pour s'assurer que le programme n'est pas sujet à des fuites
de mémoires. Ceci permet de s'assurer que le programme ne consomme pas,
en théorie, de plus en plus de mémoire lors d'une longue utilisation.
Dans un second temps, ceci est vérifié en pratique grâce à l'outil
Massif de Valgrind, celui-ci permettant d'analyser la taille de la pile
d'appel tout au long de l'exécution du programme.

Pour cela deux instances de Clipsync ont été lancées pendant une durée
de 6h30. Durant cette exécution, un script envoyant des données aléatoires
à Clipsync via Shellclip a été utilisé. Il se connecte régulièrement, avec
un intervalle variant entre une et dix secondes, à une des deux instances et
envoe un contenu aléatoire (de taille variant entre 10 et 1000 bytes).

La première instance a été lancée en utilisant l'outil
Memcheck de Valgrind dont le résultat est présent dans la figure
\ref{fig:memcheck}. Celui-ci indique qu'aucun byte n'a été perdu au cours
de l'exécution. Notons que les 14914 bytes, qui ont été indirectement perdus,
sont dûs au fait que le programme ne s'est pas terminé « naturellement »,
celui-ci tournant dans une boucle infinie.
La seconde instance a été lancée en utilisant Massif et le résultat,
montrant une utilisation de la mémoire constante ne dépassant pas 191500
bytes est présent sur la figure \ref{fig:massif}.

\begin{figure}[!h]
  \centering
  \scriptsize{
\begin{verbatim}
==23131== Memcheck, a memory error detector
==23131== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==23131== Using Valgrind-3.6.1 and LibVEX; rerun with -h for copyright info
==23131== Command: ./clipsync.exe conf.xml
==23131==
Clipsync started
Peer connected
Accept sent to peer
Accept from peer clover2 verified
Peer clover2 verified.
==23131==
==23131== HEAP SUMMARY:
==23131==     in use at exit: 131,614 bytes in 2,879 blocks
==23131==   total heap usage: 995,956 allocs, 993,077 frees, 857,337,345 bytes
  allocated
==23131==
==23131== LEAK SUMMARY:
==23131==    definitely lost: 0 bytes in 0 blocks
==23131==    indirectly lost: 0 bytes in 0 blocks
==23131==      possibly lost: 14,914 bytes in 341 blocks
==23131==    still reachable: 116,700 bytes in 2,538 blocks
==23131==         suppressed: 0 bytes in 0 blocks
==23131== Rerun with --leak-check=full to see details of leaked memory
==23131==
==23131== For counts of detected and suppressed errors, rerun with: -v
==23131== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 45 from 8)
\end{verbatim}
  }
  \caption{Résultats de Valgrind avec Memcheck sur une durée de 6h30.}
  \label{fig:memcheck}
\end{figure}

\begin{figure}[!h]
  \centering
  \scriptsize{
\begin{verbatim}
--------------------------------------------------------------------------------
Command: ./clipsync.exe conf.xml Massif arguments:
--time-unit=B ms_print arguments: massif.out.23135
--------------------------------------------------------------------------------


    KB
191.5^#
     |# : : :  @::::   ::                  :::     ::   :         ::::      :@
     |#:: : :: @:: :   ::                  :: :  ::::  ::@:      ::::::   :::@
     |#:::::::@@:: ::::::@:::::@::::@@::::::: :::: ::::::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
     |#:::::::@@:: ::::::@:::::@::::@ ::: ::: :::: ::: ::@::::::@::::::@:::::@
   0 +----------------------------------------------------------------------->GB
     0                                                                   1.610

Number of snapshots: 82
 Detailed snapshots: [1 (peak), 9, 10, 20, 26, 32, 51, 61, 71, 81]
\end{verbatim}}
    \caption{Résultats de Valgrind avec Massif sur une durée de 6h30.}
    \label{fig:massif}
\end{figure}
\section{Analyse des fonctionnalités présentes et
futures}
Le logiciel produit permet de synchroniser du texte présent dans le
presse-papier. D'autres fonctionnalités plus avancées avaient été identifiées
au début de ce rapport comme la gestion d'autres types de données comme
les images ainsi que la gestion de l'historique.

La première de ces deux fonctionnalités, qui peut par exemple servir à
synchroniser des morceaux d'images entre deux éditeurs graphiques, est
possible grâce au champ type présent dans les messages DATA. Cette intégration
nécessite cependant des modifications du code de Clipsync, en effet aucun
mécanisme n'a été mis en place pour stocker en mémoire un presse-papier
différent d'une chaîne de caractères.

Une autre fonctionnalité découlant du CCMP d'images est la compression du
presse-papier. A partir du moment où des images sont transférées sur le
réseau, la taille des données envoyées sur le réseau augmente. Il devient
alors intéressant de compresser le flux de données afin d'économiser de la
bande passante. Ces deux fonctionnalités seront (après la correction
de bugs découverts) la première priorité pour l'évolution future du logiciel.

En ce qui concerne la gestion de l'historique du presse-papier, cette
fonctionnalité n'est pas prévue afin de respecter au mieux la philosophie
UNIX et n'avoir qu'un seul outil par fonctionnalité. Ainsi Clipsync
s'occupe de la synchronisation du presse-papier, mais n'a pas pour but de
synchroniser l'historique. De plus il existe déjà un grand nombre d'outils
gérant l'historique du presse-papier et ceux-ci sont théoriquement compatibles
avec Clipsync\footnote{Des tests ont été effectuées avec XFCE-Clipman et
confirment cette hypothèse.}. Dés lors il est possible de gérer l'historique
du presse-papier en installant un tel outil sur chaque machine et d'utiliser
Clipsync uniquement pour synchroniser la donnée se situant réellemet dans
le presse-papier du système.

Une autre amélioration à prendre en compte assez rapidement est le support
de l'IPv6. En effet le fichier configuration permet d'activer IPv6 mais
cette option ne fonctionne pas. Ce problème vient du fait que l'adresse
de broadcast est récupérée via POCO à partir du nom de l'interface réseau
fournie dans le fichier de configuration. Cependant une interface n'ayant
pas d'adresse de broadcast en IPv6, Clipsync sera incapable de trouver
cette adresse de broadcast et ne peut donc fonctionner. Il sera donc nécessaire
d'adapter le logiciel en utilisant par exemple plutôt le multicast que le
broadcast.

Bien que la compression et le support des images soient deux fonctionnalités
pouvant améliorer Clipsync et lui donner une plue value importante, le passage
à l'IPv6 est cependant un problème d'actualité assez urgent. Pour cette
raison le support de l'IPv6 est prioritaire en comparaison à l'ajout des
deux fonctionnalités précédemment citées. Ceci permettra ainsi à Clipsync
d'avoir un réel avantage technique sur Remote Clip dont le seul réel défaut
est de devenir vieillissant et donc de ne pas supporter l'IPv6.

Enfin à plus long terme, il sera certainement intéressant de revoir la
structure du logiciel afin qu'il puisse rester facile à maintenir.
Une de ces améliorations pourrait être l'utilisation de \emph{Zeroconf}
\footnote{Ensemble de protocoles dont le but est de fournir des services
d'auto-configuration permettant entre autre de découvrir les services
disponibles sur un réseau local.} pouvant remplacer le système de
broadcast mis en place en utilisant une implémentation libre telle
qu'\emph{Avahi}\cite{avahi} ou \emph{Bonjour}\cite{bonjour}.