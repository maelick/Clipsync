\chapter{Implémentation de la solution proposée}
\renewcommand{\leftmark}{\thechapter.~~Implémentation de la solution proposée}
\label{chap:implem}
Ce chapitre justifiera premièrement les choix qui ont été fait avant et
pendant l'implémentationde de l'architecture baptisée \emph{Clipsync}.
Ensuite une présentation de l'utilisation des
logiciels produits sera faite. Après des vérifications de performances seront
effectuées sur ces logiciels et enfin les faiblesses du logiciel seront mises
en avant afin de déterminer les éléments prioritaires à développer lors de
l'évolution future du logiciel.

\section{Choix des outils}
Le langage de programmation C++ a été choisi afin d'implémenter Clipsync,
celui-ci permettant d'avoir un code compilé nativement et ainsi optimisé
pour la machine hôte. Bien que ceci soit une source d'erreurs, il permet
aussi de gérer la mémoire manuellement, ce qui implique un gain de
performances. En revanche les client locaux, à savoir GTKCLip et Shellclip,
ont eux été implémentés en Python. Ce langage de haut niveau en comparaison
au C++ offre la possibilité d'écrire ces deux clients sous forme de scripts
de taille réduite. La perte de performance par rapport au C++ est peu
importante vu que ces scripts utilisent un protocole de communication simple
et servent uniquement d'interface entre l'utilisateur et le client P2P.

La librairie POCO\cite{poco} a été utilisée principalement comme bibliothèque
pour la manipulation de sockets portables. Ceci permet d'avoir une
compatibilité théorique avec Microsoft Windows, bien que celle-ci n'a pas
été testée. De plus POCO offrant un grand nombre de service, la librairie
a aussi été utilisée pour la gestion des threads et des timers, la
configuration du logiciel grâce à un fichier XML, pour la protection de
zones critiques avec mutex, pour la génération de
nombres pseudo-aléatoires et pour la cryptographie. L'algorithme de chiffrement
utilisé est l'\emph{AES}\cite{daemen2002the} (Advanced Encryption Standard,
aussi connu sous le nom de \emph{Rijndael}). Etant l'algorithme choisi par le
gouvernement américain, cet algorithme utilisant une clé de 256 bits permet un
niveau de sécurité très largement acceptable.

Afin d'éviter les erreurs en C++, et en particulier les fuites de mémoire,
Valgrind\cite{valgrind} a été utilisé. Celui-ci est à la fois un debugger,
un \emph{memory-checker} et un \emph{profiler}. Celui-ci a permis de debugger
le programme pendant le développement et est utilisé dans la suite de ce
chapitre afin d'analyser les performances du logiciel et pour s'assurer que
le programme n'est pas victime de fuites de mémoires.
Bazaar\cite{bzr} a été utilisé comme gestionnaire de versions décentralisé et
Launchpad\cite{launchpad} a été choisi comme forge sur laquelle déposer le
logiciel produit.

\section{Utilisation des logiciels}
Avant de pouvoir récupérer, compiler et utiliser le logiciel, il est nécessaire
d'avoir les librairies et outils suivants:
\begin{itemize}
\item Bazaar: \url{http://bazaar.canonical.com/}
\item GCC: \url{http://gcc.gnu.org/}
\item GNU Make: \url{http://www.gnu.org/software/make/}
\item POCO version 1.3.6 minimum: \url{http://pocoproject.org/}
\item Python 2.6 ou 2.7: \url{http://www.python.org/}
\item PyGTK et GTK version 2: \url{http://www.pygtk.org/}
\item Doxygen peut être optionnellement installé pour générer la documentation
  du projet: \url{http://www.stack.nl/~dimitri/doxygen/}
\end{itemize}

Tous ces logiciels peuvent êtres installés sous une distribution GNU/Linux
basée sur une Debian récente grâce à la commande:
\begin{verbatim}
sudo apt-get install bzr gcc make libpoco-dev python-gtk2 doxygen
\end{verbatim}
Le code source peut alors être récupéré grâce à la commande:
\begin{verbatim}
bzr branch lp:clipsync
\end{verbatim}
Clipsync peut alors être compilé grâce à GNU Make dans le dossier
\emph{src/clipsync}.
L'exécutable produit peut alors être lancé en passant en paramètre un nom
de fichier XML servant à configurer le logiciel. Voici la liste des balises
et leur description:
\begin{itemize}
\item \emph{net\_frontend}:
  \begin{itemize}
  \item \emph{interface}: interface réseau utilisée pour les communications
    réseau
  \item \emph{use\_ipv6}: booléen servant à indiquer l'utilisation d'IPv6.
    Cette fonctionnalité n'est cependant pas disponible pour le moment et
    l'option a seulement été ajoutée pour l'évolution future du loigiciel.
  \item \emph{port}: port TCP utilisé pour écouter les connexions TCP
    entrantes. C'est sur ce port que le pair sera contacté par les autres
    pairs du réseau.
  \item \emph{bcast\_port}: port UDP utilisé pour l'envoi et la réception de
    messages broadcast.
  \item \emph{bcast\_interval}: interval en millisecondes utilisé pour l'envoi
    de messages broadcast.
  \item \emph{peer\_name}: nom servant à identifier ce pair sur le réseau et
    devant être unique pour ce pair.
  \item \emph{group}: nom du groupe de pairs. Chaque pair du réseau devra
    posséder le même nom de groupe dans sa configuration.
  \item \emph{passphrase} et \emph{salt}: mot de passe et sel\footnote{Le
      salage en cryptographie permet de renforcer la sécurité d'un algorithme
      de chiffrement\cite{schneier-crypto}} servant à générer la clé pour le
    chiffrement par AES. Ces deux valeurs doivent être identiques sur chaque
    pair. Il est possible de supprimer ces deux valeurs, de lancer le
    logiciel qui va générer des valeurs aléatoires qui peuvent ensuite
    être copiées sur les autres pairs.
  \item \emph{keepalive\_delay}: délai en millisecondes après lequel la
    connexion est fermée si aucun message OK n'est reçu.
  \item \emph{keepalive\_interval}: interval en millisecondes utilisé pour
    l'envoi de messages OK.
  \item \emph{verbose}, \emph{verbose\_bcast}, \emph{verbose\_peer}:
    booléens permettant d'activer ou de désactiver le mode verbeux
    \footnote{Le mode verbeux permet d'afficher sur la sortie standard
    des informations sur l'activité du logiciel.} de Clipsync.
  \end{itemize}
\item \emph{local\_frontend}:
  \begin{itemize}
  \item \emph{local\_port}: port TCP en local utilisé pour communiquer avec les
    clients locaux.
  \item \emph{verbose}: booléen activant le mode verbeux pour l'interface avec
    les clients locaux.
  \end{itemize}
\end{itemize}

Le script \emph{gen\_config.py} permet de générer un fichier de configuration
en passant en argument dans l'ordre: le nom du pair, le nom du groupe de pairs,
l'interface réseau à utiliser et optionnellement: le port, le port broadcast,
le port loccal, la longueur du mot de passe à générer et la longueur du
sel à générer.

L'utilisation de Shellclip et GTKClip est possible en exécutant les scripts
Python et en passant en paramètre le port TCP local permettant de contacter
Clipsync.

\section{Vérifications de performances}

\section{Analyse des fonctionnalités présentes et
futures}
Le logiciel produit permet de synchroniser du texte présent dans le
presse-papier. D'autres fonctionnalités plus avancées avaient été identifiées
au début de ce rapport comme la gestion d'autres types de données comme
les images ainsi que la gestion de l'historique.

La première de ces deux fonctionnalités, qui peut par exemple servir à
synchroniser des morceaux d'images entre deux éditeurs graphiques, est
possible grâce au champ type présent dans les messages DATA. Cette intégration
nécessite cependant des modifications du code de Clipsync, en effet aucun
mécanisme n'a été mis en place pour stocker en mémoire un presse-papier
différent d'une chaîne de caractères.

Une autre fonctionnalité découlant du CCMP d'images est la compression du
presse-papier. A partir du moment où des images sont transférées sur le
réseau, la taille des données envoyées sur le réseau augmente. Il devient
alors intéressant de compresser le flux de données afin d'économiser de la
bande passante. Ces deux fonctionnalités seront (après la correction
de bugs découverts) la première priorité pour l'évolution future du logiciel.

En ce qui concerne la gestion de l'historique du presse-papier, cette
fonctionnalité n'est pas prévue afin de respecter au mieux la philosophie
UNIX et n'avoir qu'un seul outil par fonctionnalité. Ainsi Clipsync
s'occupe de la synchronisation du presse-papier, mais n'a pas pour but de
synchroniser l'historique. De plus il existe déjà un grand nombre d'outils
gérant l'historique du presse-papier et ceux-ci sont théoriquement compatibles
avec Clipsync\footnote{Des tests ont été effectuées avec XFCE-Clipman et
confirment cette hypothèse.}. Dés lors il est possible de gérer l'historique
du presse-papier en installant un tel outil sur chaque machine et d'utiliser
Clipsync uniquement pour synchroniser la donnée se situant réellemet dans
le presse-papier du système.